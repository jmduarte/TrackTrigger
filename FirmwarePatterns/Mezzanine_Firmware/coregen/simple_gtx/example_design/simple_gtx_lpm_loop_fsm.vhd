--////////////////////////////////////////////////////////////////////////////////
--//   ____  ____ 
--//  /   /\/   / 
--// /___/  \  /    Vendor: Xilinx 
--// \   \   \/     Version : 2.4
--//  \   \         Application : 7 Series FPGAs Transceivers Wizard 
--//  /   /         Filename :simple_gtx_lpm_loop_fsm.vhd
--// /___/   /\     
--// \   \  /  \ 
--//  \___\/\___\ 
--//
--//
--  Description :     This module performs TX reset and initialization.
--                     
--
--
-- Module simple_gtx_lpm_loop_fsm
-- Generated by Xilinx 7 Series FPGAs Transceivers Wizard
-- 
-- 
-- (c) Copyright 2010-2012 Xilinx, Inc. All rights reserved.
-- 
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
-- 
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
-- 
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
-- 
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES. 


--*****************************************************************************

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.NUMERIC_STD.ALL;

entity drp_wr_fsm_lpm is
port 
(
lock0,lock1,lock2,lock3,clk,reset,ready   : in std_logic;
di0                                       : in std_logic_vector(15 downto 0);
holds                                     : out std_logic_vector(1 downto 0);
DI                                        : out std_logic_vector(15 downto 0);
store_di0                                 : out std_logic_vector(15 downto 0);
Address                                   : out std_logic_vector(8 downto 0);
state                                     : out std_logic_vector(4 downto 0);
kill0 ,kill1 ,kill2 ,kill3                : out std_logic;
rd_drp                                    : out std_logic;
wr_drp                                    : out std_logic 
);
end drp_wr_fsm_lpm;

architecture drp_wr_fsm_bevh of drp_wr_fsm_lpm is

  	
signal holds_reg                                : std_logic_vector(1 downto 0) := (others => '0');
signal store_di0_reg                            : std_logic_vector(15 downto 0) := (others => '0');
signal Address_reg                              : std_logic_vector(8 downto 0) := (others => '0');
signal state_reg                                : std_logic_vector(4 downto 0) := (others => '0');
signal rd_drp_reg                               : std_logic := '0';
signal kill0_reg,kill1_reg,kill2_reg,kill3_reg  : std_logic := '0';
signal done0,done1,done2,done3                  : std_logic := '0';

constant load_addr_kl   : std_logic_vector(4 downto 0) := "00001";
constant rd_drp_kl      : std_logic_vector(4 downto 0) := "00010";
constant wait_drprdy_kl : std_logic_vector(4 downto 0) := "00011";
constant mod_drp_kl     : std_logic_vector(4 downto 0) := "00100";
constant load_drp_kl    : std_logic_vector(4 downto 0) := "00101";
constant pulse_wr_kl    : std_logic_vector(4 downto 0) := "00110";
constant wait_drp_dy_kl : std_logic_vector(4 downto 0) := "00111"; 
constant load_addr_kh   : std_logic_vector(4 downto 0) := "01000";
constant rd_drp_kh      : std_logic_vector(4 downto 0) := "01001";
constant wait_drprdy_kh : std_logic_vector(4 downto 0) := "01010";
constant mod_drp_kh     : std_logic_vector(4 downto 0) := "01011";
constant load_drp_kh    : std_logic_vector(4 downto 0) := "01100";
constant pulse_wr_kh    : std_logic_vector(4 downto 0) := "01101";
constant wait_drp_dy_kh : std_logic_vector(4 downto 0) := "01110";  
constant endstate       : std_logic_vector(4 downto 0) := "01111";
constant resetstate     : std_logic_vector(4 downto 0) := "10000";					
					  
begin

holds  <= holds_reg;
store_di0 <= store_di0_reg;
Address <= Address_reg;
state <= state_reg;
rd_drp <= rd_drp_reg;
kill0 <= kill0_reg;
kill1 <= kill1_reg;
kill2 <= kill2_reg;
kill3 <= kill3_reg;

process(clk)
begin
if rising_edge(clk) then
  if(reset='1') then
	  state_reg <= resetstate;
	  holds_reg <= (others => '0');
     DI <= (others => '0'); 
     Address_reg <= (others => '0');
     wr_drp <= '0';
	  rd_drp_reg <= '0';
	  store_di0_reg <= (others => '0');
	  done0     <=  '0';
	  done1     <=  '0';	
	  done2     <=  '0';
	  done3     <=  '0';
     kill0_reg <=  '0';
	  kill1_reg <=  '0';	
	  kill2_reg <=  '0';
	  kill3_reg <=  '0';
	else  
     if((lock0='1' and lock1='0' and lock2='0' and lock3='0' ) and kill0_reg='0') then
	    case state_reg is
	  	   when resetstate =>
	         state_reg <= load_addr_kl;
		      done0 <= '0';
		      holds_reg <= "00";

 ---- KL LOOP  ----
         when load_addr_kl => 
           Address_reg <= "000101011"; 
           state_reg <= rd_drp_kl;

         when rd_drp_kl =>                    -- Start Read Sequence Wait for DRPRDY
			rd_drp_reg <= '1';
			state_reg <= wait_drprdy_kl;

         when wait_drprdy_kl =>                    --  Wait for DRPRDY
           if(ready='1') then
 			    store_di0_reg <= di0;				
			    state_reg <= mod_drp_kl;
           end if;
      
         when mod_drp_kl => 
			  rd_drp_reg <= '0';
			  store_di0_reg(11 downto 8) <= "0100";
			  state_reg <=load_drp_kl;

         when load_drp_kl => 					
			  state_reg <= pulse_wr_kl;
			  DI <= store_di0_reg;
					 	
         when pulse_wr_kl => 					
			  wr_drp <= '1';
			  state_reg <= wait_drp_dy_kl;
						
         when wait_drp_dy_kl =>
			  wr_drp <= '0'; 					
			  if(ready='1') then
			    state_reg <= load_addr_kh;  
           end if;
          ------ KH LOOP  ------

         when load_addr_kh => 
           Address_reg <= "000101010"; 
           state_reg <= rd_drp_kh;
           store_di0_reg <= (others => '0');
 			  DI <=(others => '0');

         when rd_drp_kh =>                    -- Start Read Sequence Wait for DRPRDY
		     rd_drp_reg <= '1';
			  state_reg <= wait_drprdy_kh;

			when wait_drprdy_kh =>               --  Wait for DRPRDY
           if(ready='1') then
			    rd_drp_reg <= '0';				
			    store_di0_reg <= di0;
			    state_reg <= mod_drp_kh;
           end if;

			when mod_drp_kh => 
			rd_drp_reg <= '0';
			store_di0_reg(11 downto 8) <= "0100";
			state_reg <= load_drp_kh;
		
         when load_drp_kh => 					
			  state_reg <= pulse_wr_kh;
			  DI <= store_di0_reg;
					 	
         when pulse_wr_kh => 					
			  wr_drp <= '1';
			  state_reg <= wait_drp_dy_kh;
						
         when wait_drp_dy_kh =>
           if(ready='1') then
		        wr_drp <= '0';
              done0 <= '1';
		        state_reg <= endstate;  
           end if;
							
         when endstate => 
		       DI <= (others => '0');
		       Address_reg <= (others => '0');
		       wr_drp <= '0';
		       rd_drp_reg <= '0';
		       kill0_reg <= done0;
		       store_di0_reg <= (others => '0');
		       state_reg <= resetstate;
		
         when others => state_reg  <= "XXXXX"; 
 
     end case;	
   elsif((lock1='1' and lock2='0' and lock3='0') and kill1_reg='0') then
       case state_reg is
	  	  
	      when resetstate =>
	        state_reg <= load_addr_kl;
		     store_di0_reg <= (others => '0');
           DI <= (others => '0');
		     done1 <= '0';
 ---- KL LOOP  ----
		
         when load_addr_kl =>
           Address_reg <= "000101011"; 
			  store_di0_reg <= (others => '0');
           state_reg <= rd_drp_kl;

         when rd_drp_kl =>                    -- Start Read Sequence Wait for DRPRDY
			rd_drp_reg <= '1';
			state_reg <= wait_drprdy_kl;

         when wait_drprdy_kl =>                    --  Wait for DRPRDY
           if(ready='1') then
             rd_drp_reg <= '0';				
			    store_di0_reg <= di0;
			    state_reg <= mod_drp_kl;
           end if;

         when mod_drp_kl => 
			  rd_drp_reg <= '0';
			  store_di0_reg(11 downto 8) <= "0011";
			  state_reg <= load_drp_kl;

         when load_drp_kl => 					
			state_reg <= pulse_wr_kl;
			DI <= store_di0_reg;
					 	
         when pulse_wr_kl => 					
			  wr_drp <= '1';
			  state_reg <= wait_drp_dy_kl;
						
         when wait_drp_dy_kl =>
           if(ready='1') then
			    wr_drp <= '0';
             state_reg <= load_addr_kh;  
           end	if;
          ------ KH LOOP  ------

         when load_addr_kh => 
           Address_reg <= "000101010"; 
			  store_di0_reg <= (others => '0');
           DI <= (others => '0');
           state_reg <= rd_drp_kh; 

         when rd_drp_kh =>                    -- Start Read Sequence Wait for DRPRDY
		     rd_drp_reg <= '1';
			  state_reg <= wait_drprdy_kh;

         when wait_drprdy_kh =>                   --  Wait for DRPRDY
           if(ready='1') then 
			    rd_drp_reg <= '0';				
			    store_di0_reg <= di0;
			    state_reg <= mod_drp_kh;
           end if;

         when mod_drp_kh => 
			rd_drp_reg <= '0';
			store_di0_reg(11 downto 8)<= "0011";
			state_reg <= load_drp_kh;

         when load_drp_kh => 					
			  state_reg <= pulse_wr_kh;
			  DI <= store_di0_reg;
	               
         when pulse_wr_kh =>
			  wr_drp <= '1';
			  state_reg <= wait_drp_dy_kh;
						
         when wait_drp_dy_kh =>
           if(ready='1') then
			    wr_drp <= '0';
             done1 <= '1';
			    state_reg <= endstate;  
           end if;
 								
         when endstate =>
			  DI <= (others => '0');
			  Address_reg <= (others => '0');
			  wr_drp <= '0';
			  rd_drp_reg <= '0';
			  kill1_reg <= done1;
			  store_di0_reg <= (others => '0');
			  state_reg <= resetstate; 
		
         when others => state_reg <= "XXXXX"; 
 
       end case;
     elsif(lock2='1' and lock3='0' and kill2_reg='0') then
	      case state_reg is

	        when resetstate =>
	          state_reg <= load_addr_kl;
		       done2 <= '0';
 ---- KL LOOP  ----
		
           when load_addr_kl => 
             Address_reg <= "000101011"; 
 			    store_di0_reg <= (others => '0');
             DI <= (others => '0');
             state_reg <= rd_drp_kl;

           when rd_drp_kl =>                    -- Start Read Sequence Wait for DRPRDY
			    rd_drp_reg <= '1';
			    state_reg <= wait_drprdy_kl;

           when wait_drprdy_kl =>                    --  Wait for DRPRDY
             if(ready='1') then
               rd_drp_reg <= '0';				
			      store_di0_reg <= di0;
			      state_reg <= mod_drp_kl;
             end if;

           when mod_drp_kl => 
			    rd_drp_reg <= '0';
			    store_di0_reg(11 downto 8) <= "0010";
			    state_reg <= load_drp_kl;
		
           when load_drp_kl => 					
			    state_reg <= pulse_wr_kl;
			    DI <= store_di0_reg;
					 	
           when pulse_wr_kl => 					
			    wr_drp <= '1';
			    state_reg <= wait_drp_dy_kl;

           when wait_drp_dy_kl =>
             if(ready='1') then
			      wr_drp <= '0';
               state_reg <= load_addr_kh;  
             end if;
          ------ KH LOOP  ------

           when load_addr_kh =>
             Address_reg <= "000101010"; 
			    store_di0_reg <= (others => '0');
             DI <= (others => '0');
             state_reg <= rd_drp_kh; 

           when rd_drp_kh =>                    -- Start Read Sequence Wait for DRPRDY
		       rd_drp_reg <= '1';
			    state_reg <= wait_drprdy_kh;
			
           when wait_drprdy_kh =>                    --  Wait for DRPRDY
			    if(ready='1') then
			rd_drp_reg <= '0';				
			store_di0_reg <= di0;
			state_reg <= mod_drp_kh;
             end if;

           when mod_drp_kh => 
			rd_drp_reg <= '0';
			store_di0_reg(11 downto 8) <= "0010";
			state_reg <=load_drp_kh;
		
          when load_drp_kh => 					
			state_reg <=pulse_wr_kh;
			DI <= store_di0_reg;
					 	
          when pulse_wr_kh => 					
			wr_drp <= '1';
			state_reg <= wait_drp_dy_kh;
						
          when wait_drp_dy_kh =>
            if(ready='1') then
			wr_drp <= '0';
                        done2<= '1';
			state_reg <= endstate;  
            end if;
								
           when endstate =>
			DI <= (others => '0');
			Address_reg <= (others => '0');
			wr_drp <= '0';
			rd_drp_reg <= '0';
			store_di0_reg <= (others => '0');
			kill2_reg <= done2;
			state_reg <= resetstate; 
		
         when others =>  state_reg <= "XXXXX"; 
 
     end case;

   elsif(lock3='1' and kill3_reg='0') then
	    	  
	    case state_reg is
	  
	     when resetstate =>
	       state_reg <= load_addr_kl;
		    done3 <= '0';
 ---- KL LOOP  ----
		
        when load_addr_kl => 
          Address_reg <= "000101011"; 
			store_di0_reg <= (others => '0');
         DI <= (others => '0');
         state_reg <= rd_drp_kl;

        when rd_drp_kl =>                    -- Start Read Sequence Wait for DRPRDY
			rd_drp_reg <= '1';
			state_reg <= wait_drprdy_kl;

        when wait_drprdy_kl =>                    --  Wait for DRPRDY
          if(ready='1') then
            rd_drp_reg <= '0';				
			   store_di0_reg <= di0;
			   state_reg <= mod_drp_kl;
          end if;

        when mod_drp_kl => 
			rd_drp_reg <= '0';
			store_di0_reg(11 downto 8) <= "0000";
			state_reg <= load_drp_kl;
		
        when load_drp_kl => 					
			state_reg <= pulse_wr_kl;
			DI <= store_di0_reg;
					 	
        when pulse_wr_kl => 					
			wr_drp <= '1';
			state_reg <= wait_drp_dy_kl;
						
        when wait_drp_dy_kl =>
          if(ready='1') then
			   wr_drp <= '0';
            state_reg <= load_addr_kh;  
          end if;
          ------ KH LOOP  ------

         when load_addr_kh => 
           Address_reg <= "000101010"; 
			  store_di0_reg <= (others => '0');
           DI <= (others => '0');
           state_reg <= rd_drp_kh; 

         when rd_drp_kh =>                    -- Start Read Sequence Wait for DRPRDY
		     rd_drp_reg <= '1';
			  state_reg <= wait_drprdy_kh;

         when wait_drprdy_kh =>                    --  Wait for DRPRDY
           if(ready='1') then
			    rd_drp_reg <= '0';				
			    store_di0_reg <= di0;
			    state_reg <= mod_drp_kh;
           end if;

         when mod_drp_kh => 
			rd_drp_reg <= '0';
			store_di0_reg(11 downto 8) <= "0000";
			state_reg <= load_drp_kh;
		
         when load_drp_kh => 					
			state_reg <= pulse_wr_kh;
			DI <= store_di0_reg;
					 	
         when pulse_wr_kh =>					
			wr_drp <= '1';
			state_reg <= wait_drp_dy_kh;
						
         when wait_drp_dy_kh =>
           if(ready='1') then
			    wr_drp <= '0';
             done3 <= '1';
			    state_reg <= endstate;  
           end if;	
								
         when endstate =>
			holds_reg <= "11";
			DI <= (others => '0');
			Address_reg <= (others => '0');
			wr_drp <= '0';
			rd_drp_reg <= '0';
			store_di0_reg <= (others => '0');
			kill3_reg <= done3;
			state_reg <= resetstate; 
		
         when others => state_reg <= "XXXXX"; 
 
     end case;
   end if;
 end if;
end if;
end process;

end drp_wr_fsm_bevh; 


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;

entity lock_detect_lpm is
port(
  lock0,lock1,lock2,lock3,start : out std_logic;
  count_lock_out  : in std_logic_vector(31 downto 0);
  usr_clk         : in integer range 0 to 4095;
  dclk,reset      : in std_logic
);
end lock_detect_lpm;

architecture lock_detect_bevh of lock_detect_lpm is

signal lock0_reg,lock1_reg,lock2_reg,lock3_reg,start_reg : std_logic := '0';

begin

start  <=     start_reg;
lock0  <=     lock0_reg;
lock1  <=     lock1_reg;
lock2  <=     lock2_reg;
lock3  <=     lock3_reg;

process(dclk)
begin
  if rising_edge(dclk) then    
    if(reset='1') then
      lock0_reg  <=  '0';
      lock1_reg  <=  '0';
      lock2_reg  <=  '0';
      lock3_reg  <=  '0';
      start_reg  <=  '0';  
    else 
      start_reg  <=  '1';
      if(count_lock_out=X"00000005") then
        lock0_reg <= '1';
      elsif(UNSIGNED(count_lock_out)=(1500*usr_clk)) then
        lock1_reg <= '1';
      elsif(UNSIGNED(count_lock_out)=(3000*usr_clk)) then
        lock2_reg <= '1';
      elsif(UNSIGNED(count_lock_out)=(4500*usr_clk)) then
        lock3_reg <= '1';
        start_reg <= '0';
      end if;
    end if;
  end if;
end process;

end lock_detect_bevh;


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.NUMERIC_STD.ALL;

entity counter_lpm is
port
(
reset,start,stop     : in std_logic;
dclk                 : in std_logic;
count_lock_out       : out std_logic_vector(31 downto 0)
);
end counter_lpm;

architecture counter_lpm_bevh of counter_lpm is

signal count_lock_out_reg : std_logic_vector(31 downto 0) := (others=>'0');

begin

count_lock_out <= count_lock_out_reg;

process(dclk)
begin 
  if rising_edge(dclk) then
    if(reset='1' or stop='1') then
      count_lock_out_reg <= (others=>'0');
    elsif(start='1') then
      count_lock_out_reg <= count_lock_out_reg + '1';
    else
      count_lock_out_reg <= (others=>'0');
    end if;
  end if;
end process;

end counter_lpm_bevh;

--------/LPM MODE KL KH SPEEDUP------/
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.NUMERIC_STD.ALL;

entity simple_gtx_lpm_loop_fsm is
generic (
 usr_clk: integer range 0 to 4095 := 3
 );
Port( 
DCLK              : in std_logic;
reset             : in std_logic;
DRDY              : in std_logic;
DO                : in std_logic_vector(15 downto 0);
holds             : out std_logic_vector(1 downto 0);
DI                : out std_logic_vector(15 downto 0);
DADDR             : out std_logic_vector(8 downto 0);
DWE,DEN,kill3     : out std_logic;
state             : out std_logic_vector(4 downto 0);
count_lock_out    : out std_logic_vector(31 downto 0);
store_di0         : out std_logic_vector(15 downto 0);
start,enable,kill0,kill1,kill2,lock0,lock1,lock2,lock3 : out std_logic
);
end simple_gtx_lpm_loop_fsm;

architecture lpm_loop_fsm_bevh of simple_gtx_lpm_loop_fsm is

component drp_wr_fsm_lpm 
port 
(
lock0,lock1,lock2,lock3,clk,reset,ready   : in std_logic;
di0                                       : in std_logic_vector(15 downto 0);
holds                                     : out std_logic_vector(1 downto 0);
DI                                        : out std_logic_vector(15 downto 0);
store_di0                                 : out std_logic_vector(15 downto 0);
Address                                   : out std_logic_vector(8 downto 0);
state                                     : out std_logic_vector(4 downto 0);
kill0 ,kill1 ,kill2 ,kill3                : out std_logic;
rd_drp                                    : out std_logic;
wr_drp                                    : out std_logic 
);
end component;

component lock_detect_lpm
port(
  lock0,lock1,lock2,lock3,start : out std_logic;
  count_lock_out  : in std_logic_vector(31 downto 0);
  usr_clk         : in integer range 0 to 4095;
  dclk,reset      : in std_logic
);
end component;

component counter_lpm
port
(
reset,start,stop     : in std_logic;
dclk                 : in std_logic;
count_lock_out       : out std_logic_vector(31 downto 0)
);
end component;

signal rd_drp : std_logic;
signal wr_drp : std_logic;
signal done   : std_logic := '0';
signal lock0_reg,lock1_reg,lock2_reg,lock3_reg,start_reg : std_logic := '0';
signal holds_reg             : std_logic_vector(1 downto 0);
signal DADDR_reg             : std_logic_vector(8 downto 0);
signal kill3_reg,kill2_reg   : std_logic;
signal count_lock_out_reg    : std_logic_vector(31 downto 0);
signal enable_reg,kill0_reg,kill1_reg : std_logic;

begin

DWE    <= wr_drp;
DEN    <= rd_drp or wr_drp;
start  <=     start_reg;
lock0  <=     lock0_reg;
lock1  <=     lock1_reg;
lock2  <=     lock2_reg;
lock3  <=     lock3_reg;
holds  <=     holds_reg;
DADDR  <=     DADDR_reg;
kill0  <=     kill0_reg;
kill1  <=     kill1_reg;
kill2  <=     kill2_reg;
kill3  <=     kill3_reg;
count_lock_out <= count_lock_out_reg;
enable <= enable_reg;

I1 : drp_wr_fsm_lpm
port map
(	
	lock0       => lock0_reg,
	lock1       => lock1_reg,
	lock2       => lock2_reg,
	lock3       => lock3_reg,
	clk         => DCLK,
	reset       => reset,
	ready       => DRDY,
	holds       => holds_reg,
	kill0       => kill0_reg,
	store_di0   => store_di0,
	kill1       => kill1_reg,
	kill2       => kill2_reg,
	kill3       => kill3_reg,
	state       => state,
	DI          => DI,
	di0         => DO,
	Address     => DADDR_reg,
	rd_drp      => rd_drp,
	wr_drp      => wr_drp
);


I2 : lock_detect_lpm 
port map
( 
	start             => start_reg,
	count_lock_out    => count_lock_out_reg,
	usr_clk           => usr_clk,
	dclk              => DCLK,
	reset             => reset,
	lock0             => lock0_reg,
	lock1             => lock1_reg,
	lock2             => lock2_reg,
	lock3             => lock3_reg
);

I3 : counter_lpm
port map(
	dclk           => DCLK,
	reset          => reset,
   count_lock_out => count_lock_out_reg,
	start          => start_reg,
	stop           => done 
);

end lpm_loop_fsm_bevh;

